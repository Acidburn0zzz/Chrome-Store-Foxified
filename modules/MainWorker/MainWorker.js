// Imports
importScripts('resource://gre/modules/osfile.jsm');
importScripts('resource://gre/modules/workers/require.js');

// Globals
var core = { // have to set up the main keys that you want when aCore is merged from mainthread in init
	addon: {
		path: {
			modules: 'chrome://chrome-store-foxified/content/modules/'
		}
	},
	os: {
		name: OS.Constants.Sys.Name.toLowerCase()
	}
};

var OSStuff = {}; // global vars populated by init, based on OS

// Imports that use stuff defined in chrome
// I don't import ostypes_*.jsm yet as I want to init core first, as they use core stuff like core.os.isWinXP etc
// imported scripts have access to global vars on MainWorker.js
// importScripts(core.addon.path.modules + 'cutils.jsm');
// importScripts(core.addon.path.modules + 'ctypes_math.jsm');
importScripts(core.addon.path.modules + 'jsonwebtoken.js');

// Setup PromiseWorker
// SIPWorker - rev2 - https://gist.github.com/Noitidart/92e55a3f7761ed60f14c
var PromiseWorker = require('resource://gre/modules/workers/PromiseWorker.js');

// Instantiate AbstractWorker (see below).
var worker = new PromiseWorker.AbstractWorker()

worker.dispatch = function(method, args = []) {
  // Dispatch a call to method `method` with args `args`
  return self[method](...args);
};
worker.postMessage = function(...args) {
  // Post a message to the main thread
  self.postMessage(...args);
};
worker.close = function() {
  // Close the worker
  self.close();
};
worker.log = function(...args) {
  // Log (or discard) messages (optional)
  dump('Worker: ' + args.join(' ') + '\n');
};

// Connect it to message port.
// self.addEventListener('message', msg => worker.handleMessage(msg)); // this is what you do if you want PromiseWorker without mainthread calling ability
// start - setup SIPWorker
var WORKER = this;
self.addEventListener('message', function(aMsgEvent) { // this is what you do if you want SIPWorker mainthread calling ability
	var aMsgEventData = aMsgEvent.data;
	if (Array.isArray(aMsgEventData)) {
		console.error('worker got response for main thread calling SIPWorker functionality:', aMsgEventData)
		var funcName = aMsgEventData.shift();
		if (funcName in WORKER) {
			var rez_worker_call = WORKER[funcName].apply(null, aMsgEventData);
		}
		else { console.error('funcName', funcName, 'not in scope of WORKER') } // else is intentionally on same line with console. so on finde replace all console. lines on release it will take this out
	} else {
		console.error('no this is just regular promise worker message');
		worker.handleMessage(aMsgEvent)
	}
});

const SIP_CB_PREFIX = '_a_gen_cb_';
const SIP_TRANS_WORD = '_a_gen_trans_';
var sic_last_cb_id = -1;
self.postMessageWithCallback = function(aPostMessageArr, aCB, aPostMessageTransferList) {
	var aFuncExecScope = WORKER;
	
	sic_last_cb_id++;
	var thisCallbackId = SIP_CB_PREFIX + sic_last_cb_id;
	aFuncExecScope[thisCallbackId] = function() {
		delete aFuncExecScope[thisCallbackId];
		console.log('in worker callback trigger wrap, will apply aCB with these arguments:', arguments);
		aCB.apply(null, arguments[0]);
	};
	aPostMessageArr.push(thisCallbackId);
	self.postMessage(aPostMessageArr, aPostMessageTransferList);
};
// end - setup SIPWorker

// Define a custom error prototype.
function MainWorkerError(name, msg) {
  this.msg = msg;
  this.name = name;
}
MainWorkerError.prototype.toMsg = function() {
	return {
		exn: 'MainWorkerError',
		msg: this.msg,
		name: this.name
	};
};
////// end of imports and definitions

function init(objCore) { // function name init required for SIPWorker
	//console.log('in worker init');
	
	// merge objCore into core
	// core and objCore is object with main keys, the sub props
	
	core = objCore;

	core.os.mname = core.os.toolkit.indexOf('gtk') == 0 ? 'gtk' : core.os.name; // mname stands for modified-name	
	
	// OS Specific Init
	switch (core.os.name) {
		// case 'winnt':
		// case 'winmo':
		// case 'wince':
		// 		
		// 		OSStuff.hiiii = true;
		// 		
		// 	break;
		default:
			// do nothing special
	}
	
	// chrome store foxified custom init, get l10n packages
	formatStringFromName('addon_name', [], 'bootstrap')
	formatStringFromName('add_to_firefox', [], 'inlay')
	
	var rezInit = {};
	rezInit.l10n = _cache_formatStringFromName_packages;
	
	console.log('MainWorker init success');
	return rezInit; // required for SIPWorker
}

// Start - Addon Functionality
function jpmSign(aPlatformPathToXpi, aAddonVersionInXpi, aAddonIdInXpi, aPlatofrmPathToDownloaDir, aAmoApiKey, aAmoApiSecret) {
	// requires Cu.importGlobalProperties(['File']);
	// requires core.addon.path.content + 'modules/jsonwebtoken.js'
	// requires OS.File
	
	// Returns
		// promise
			// resolve
				// string - platform path to the signed xpi. its the aPlatofrmPathToDownloaDir joined with the file name generated by AMO. because AMO generates a file name
	
	var deferredMain_jpmSign = new Deferred();
	var cMsToWaitBefore_FirstStatusCheck = 1000;
	var cMsToWaitAfter_FirstStatusCheck = 4000;
	
	var cJpmSignTimer = Cc['@mozilla.org/timer;1'].createInstance(Ci.nsITimer);
	
	if (!('generateToken' in bootstrap)) {
		Services.scriptloader.loadSubScript(core.addon.path.content + 'modules/jsonwebtoken.js', bootstrap);
	}
	
	var submitXpi = function() {
		var myDomFile = new File(aPlatformPathToXpi);
		console.log('myDomFile:', myDomFile);
		
		var formData = Cc['@mozilla.org/files/formdata;1'].createInstance(Ci.nsIDOMFormData); // http://stackoverflow.com/q/25038292/1828637
		formData.append('Content-Type', 'multipart/form-data');
		formData.append('upload', myDomFile); // http://stackoverflow.com/a/24746459/1828637
		
		// var promise_sign = xhr('https://addons.mozilla.org/api/v3/addons/' + encodeURIComponent(aAddonIdInXpi) + '/versions/initial/', { // this ```' + encodeURIComponent('nsitimer@jetpack') + '``` can be anything you want
		var promise_sign = xhr('https://addons.mozilla.org/api/v3/addons/' + encodeURIComponent(aAddonIdInXpi) + '/versions/' + aAddonVersionInXpi + '/', { // only on first time upload, the aAddonVersionInXpi can be anything
			method: 'PUT',
			data: formData,
			responseType: 'json',
			headers: {
				Authorization: 'JWT ' + generateToken(aAmoApiKey, aAmoApiSecret)
			}
		});
		
		promise_sign.then(
			function(aVal) {
				console.log('Fullfilled - promise_sign - ', aVal);
				if (aVal.statusText == 'UNAUTHORIZED') {
					console.error('stupid thing got invalid credentials, so retry');
					xpcomSetTimeout(cJpmSignTimer, 1500, submitXpi);
					return;
				}
				if (aVal.response.error) {
					// check if this version is already upload, and if it is, then download it
					checkPrexisting();
					// deferredMain_jpmSign.reject('AMO Submit API Error - ' + aVal.response.error);
				} else {
					if (aVal.response.detail == 'Incorrect authentication credentials.') {
						console.error('wtf wrong credentials??? try again');
						deferredMain_jpmSign.reject('AMO Submit API Error - ' + aVal.response.detail);
					} else {
						xpcomSetTimeout(cJpmSignTimer, cMsToWaitBefore_FirstStatusCheck, function() { checkSignStatus((aVal.response.url)) });
					}
				}
			},
			genericReject.bind(null, 'promise_sign', deferredMain_jpmSign)
		).catch(genericCatch.bind(null, 'promise_sign', deferredMain_jpmSign));
	};
	
	var checkPrexisting = function() {
		var promise_findPrexist = xhr('https://addons.mozilla.org/api/v3/addons/' + encodeURIComponent(aAddonIdInXpi) + '/versions/' + aAddonVersionInXpi + '/', {
			responseType: 'json',
			headers: {
				Authorization: 'JWT ' + generateToken(aAmoApiKey, aAmoApiSecret)
			}
		});
		promise_findPrexist.then(
			function(aVal) {
				console.log('Fullfilled - promise_findPrexist - ', aVal);
				if (aVal.statusText == 'UNAUTHORIZED') {
					console.error('stupid thing got invalid credentials, so retry');
					xpcomSetTimeout(cJpmSignTimer, 1500, checkPrexisting);
					return;
				}
				if (aVal.response.error) {
					if (aVal.response.error == 'No uploaded file for that addon and version.') {
						// it probably == 'No uploaded file for that addon and version.'
						deferredMain_jpmSign.reject('AMO Submit API errored, and prexisting does not exist!');
					} else {
						deferredMain_jpmSign.reject('AMO Submit API errored, and check for prexisting returned - ' + aVal.response.error);
					}
				} else {
					if (aVal.response.files && aVal.response.files.length > 0) {
						console.log('ok GOOOOOOD found a that this addon id and version was already pre-existing so lets download that');
						downloadSigned(aVal.response.files[0].download_url);
					} else {
						deferredMain_jpmSign.reject('AMO Submit API errored, and check for prexisting returned NO ERROR - BUT there are no files in response json! json: ' + JSON.stringify(aVal.response));
					}
				}
			},
			genericReject.bind(null, 'promise_findPrexist', deferredMain_jpmSign)
		).catch(genericCatch.bind(null, 'promise_findPrexist', deferredMain_jpmSign));
	};
	
	var checkSignStatus = function(aCheckSignedURL) {
		// this url is also available in json of promise_sign as .url. that url contains the .pk if you dont want to build it yourself then use the format ``` GET /api/v3/addons/[string:add-on-id]/versions/[string:version]/(uploads/[string:upload-pk]/)``` and put .pk from above
		var promise_signStatus = xhr(aCheckSignedURL, {
			responseType: 'json',
			headers: {
				Authorization: 'JWT ' + generateToken(aAmoApiKey, aAmoApiSecret)
			}
		});
		promise_signStatus.then(
			function(aVal) {
				console.log('Fullfilled - promise_signStatus - ', aVal);
				if (aVal.statusText == 'UNAUTHORIZED') {
					console.error('stupid thing got invalid credentials, so retry');
					xpcomSetTimeout(cJpmSignTimer, 1500, function() { checkSignStatus(aCheckSignedURL) });
					return;
				}
				if (aVal.response.processed) {
					if (!aVal.response.reviewed) {
						// file:///C:/Users/Mercurius/Pictures/Screenshot%20-%20Wednesday,%20January%2013,%202016%206-09-53%20PM.png
						// submission went through, but auto review not yet completed, so file are not ready
						xpcomSetTimeout(cJpmSignTimer, cMsToWaitAfter_FirstStatusCheck, function() { checkSignStatus(aCheckSignedURL) });
					} else {
						if (aVal.response.files && aVal.response.files.length > 0) {
							// files ready
							// C:\Users\Mercurius\Documents\jpm sign status when its good - after ready - with details showing on arr.png
							downloadSigned(aVal.response.files[0].download_url);
						} else {
							deferredMain_jpmSign.reject('AMO Review API Error - The submission was reviewed (json.reviewed:true) however no files were given, so maybe it failed review (passed_reivew != true)?');
							console.error('AMO Review API Error - The submission was reviewed (json.reviewed:true) however no files were given, so maybe it failed review (passed_reivew != true)?', 'response.json:', aVal.response);
							// actually never mind this block here i dont think it happens
							// // THIS CAN HAPPEN!! weird that it can be reviewed:true, but files are not yet ready
							// // files not yet ready - but validation passed - so we know for sure file will come soon - so keep checking
							// // file:///C:/Users/Mercurius/Documents/jpm%20sign%20status%20when%20its%20good%20-%20because%20i%20saw%20on%20amo%20-%20but%20files%20not%20yet%20ready.png
							// checkSignStatus(aCheckSignedURL, cMsToWaitAfter_FirstStatusCheck);
						}
					}
				} else {
					// so keep checking as yet processed so dont know result
					// file:///C:/Users/Mercurius/Documents/jpm%20sign%20status%20when%20not%20yet%20processed.png
					checkSignStatus(aVal.response.url, cMsToWaitAfter_FirstStatusCheck);
				}
			},
			genericReject.bind(null, 'promise_signStatus', deferredMain_jpmSign)
		).catch(genericCatch.bind(null, 'promise_signStatus', deferredMain_jpmSign));
	};
	
	var downloadSigned = function(aDownloadSignedURL) {
		var signedXpiFileName = aDownloadSignedURL.substring(aDownloadSignedURL.lastIndexOf('/') + 1, aDownloadSignedURL.indexOf('?src=api'));
		
		var promise_downloadSigned = xhr(aDownloadSignedURL, {
			responseType: 'arraybuffer',
			headers: {
				Authorization: 'JWT ' + generateToken(gAmoApiKey, gAmoApiSecret)
			}
		});
		promise_downloadSigned.then(
			function(aVal) {
				console.log('Fullfilled - promise_downloadSigned - ', aVal);
				if (aVal.statusText == 'UNAUTHORIZED') {
					console.error('stupid thing got invalid credentials, so retry');
					xpcomSetTimeout(cJpmSignTimer, 1500, function() { downloadSigned(aDownloadSignedURL) });
					return;
				}

				saveSignedToDisk(signedXpiFileName, aVal.response);
			},
			genericReject.bind(null, 'promise_downloadSigned', deferredMain_jpmSign)
		).catch(genericCatch.bind(null, 'promise_downloadSigned', deferredMain_jpmSign));
	};
	
	var saveSignedToDisk = function(aSignedXpiFileName, aSignedXpiArrBuf) {
		cJpmSignTimer = null;
		var platformPathToSignedXpi = OS.Path.join(aPlatofrmPathToDownloaDir, aSignedXpiFileName);
		var promise_saveXpi = OS.File.writeAtomic(platformPathToSignedXpi, new Uint8Array(aSignedXpiArrBuf));
		promise_saveXpi.then(
			function(aVal) {
				console.log('Fullfilled - promise_saveXpi - ', aVal);
				deferredMain_jpmSign.resolve(platformPathToSignedXpi);
			},
			genericReject.bind(null, 'promise_saveXpi', deferredMain_jpmSign)
		).catch(genericCatch.bind(null, 'promise_saveXpi', deferredMain_jpmSign));
	};
	
	submitXpi();
	
	return deferredMain_jpmSign.promise;
}

	// var promise_jpmSign = jpmSign(OS.Path.join(OS.Constants.Path.desktopDir, 'nsi2.xpi'), '0.3', 'Bootstrap-nsITimer-EIGHT@jetpack', OS.Constants.Path.desktopDir, gAmoApiKey, gAmoApiSecret);
	// promise_jpmSign.then(
		// function(aVal) {
			// console.log('Fullfilled - promise_jpmSign - ', aVal);
			
		// },
		// genericReject.bind(null, 'promise_jpmSign', 0)
	// ).catch(genericCatch.bind(null, 'promise_jpmSign', 0));

function doit(aExtId, aExtName) {
	console.log('in doit:', aExtId, aExtName);
	
	return ['promise_rejected']; // must return array as this function is designed to return to callInPromiseWorker
}
// End - Addon Functionality

// start - common helper functions
function escapeRegExp(text) {
	if (!arguments.callee.sRE) {
		var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];
		arguments.callee.sRE = new RegExp('(\\' + specials.join('|\\') + ')', 'g'); // doesnt work in strict mode ```'use strict';```
	}
	return text.replace(arguments.callee.sRE, '\\$1');
}

// rev1 - https://gist.github.com/Noitidart/8684e8f9488bd0bdc3f8 - https://gist.github.com/Noitidart/8684e8f9488bd0bdc3f8
var gTxtDecodr; // holds TextDecoder if created
function getTxtDecodr() {
	if (!gTxtDecodr) {
		gTxtDecodr = new TextDecoder();
	}
	return gTxtDecodr;
}
var gTxtEncodr; // holds TextDecoder if created
function getTxtEncodr() {
	if (!gTxtEncodr) {
		gTxtEncodr = new TextEncoder();
	}
	return gTxtEncodr;
}

function validateOptionsObj(aOptions, aOptionsDefaults) {
	// ensures no invalid keys are found in aOptions, any key found in aOptions not having a key in aOptionsDefaults causes throw new Error as invalid option
	for (var aOptKey in aOptions) {
		if (!(aOptKey in aOptionsDefaults)) {
			console.error('aOptKey of ' + aOptKey + ' is an invalid key, as it has no default value, aOptionsDefaults:', aOptionsDefaults, 'aOptions:', aOptions);
			throw new Error('aOptKey of ' + aOptKey + ' is an invalid key, as it has no default value');
		}
	}
	
	// if a key is not found in aOptions, but is found in aOptionsDefaults, it sets the key in aOptions to the default value
	for (var aOptKey in aOptionsDefaults) {
		if (!(aOptKey in aOptions)) {
			aOptions[aOptKey] = aOptionsDefaults[aOptKey];
		}
	}
}

function xhr(aUrlOrFileUri, aOptions={}) {
	// console.error('in xhr!!! aUrlOrFileUri:', aUrlOrFileUri);
	
	// all requests are sync - as this is in a worker
	var aOptionsDefaults = {
		responseType: 'text',
		timeout: 0, // integer, milliseconds, 0 means never timeout, value is in milliseconds
		headers: null, // make it an object of key value pairs
		method: 'GET', // string
		data: null // make it whatever you want (formdata, null, etc), but follow the rules, like if aMethod is 'GET' then this must be null
	};
	validateOptionsObj(aOptions, aOptionsDefaults);
	
	var cRequest = new XMLHttpRequest();
	
	cRequest.open(aOptions.method, aUrlOrFileUri, false); // 3rd arg is false for synchronus
	
	if (aOptions.headers) {
		for (var h in aOptions.headers) {
			cRequest.setRequestHeader(h, aOptions.headers[h]);
		}
	}
	
	cRequest.responseType = aOptions.responseType;
	cRequest.send(aOptions.data);
	
	// console.log('response:', cRequest.response);
	
	// console.error('done xhr!!!');
	return cRequest;
}

var _cache_formatStringFromName_packages = {}; // holds imported packages
function formatStringFromName(aKey, aReplacements, aLocalizedPackageName) {
	// depends on ```core.addon.path.locale``` it must be set to the path to your locale folder

	// aLocalizedPackageName is name of the .properties file. so mainworker.properties you would provide mainworker
	// aKey - string for key in aLocalizedPackageName
	// aReplacements - array of string
	
	if (!_cache_formatStringFromName_packages[aLocalizedPackageName]) {
		var packageStr = xhr(core.addon.path.locale + aLocalizedPackageName + '.properties').response;
		var packageJson = {};
		
		var propPatt = /(.*?)=(.*?)$/gm;
		var propMatch;
		while (propMatch = propPatt.exec(packageStr)) {
			packageJson[propMatch[1]] = propMatch[2];
		}
		
		_cache_formatStringFromName_packages[aLocalizedPackageName] = packageJson;
		
		console.log('packageJson:', packageJson);
	}
	
	var cLocalizedStr = _cache_formatStringFromName_packages[aLocalizedPackageName][aKey];
	if (aReplacements) {
		for (var i=0; i<aReplacements.length; i++) {
			cLocalizedStr = cLocalizedStr.replace('%S', aReplacements[i]);
		}
	}
	
	return cLocalizedStr;
}



// rev1 - https://gist.github.com/Noitidart/c4ab4ca10ff5861c720b
var jQLike = { // my stand alone jquery like functions
	serialize: function(aSerializeObject) {
		// https://api.jquery.com/serialize/

		// verified this by testing
			// http://www.w3schools.com/jquery/tryit.asp?filename=tryjquery_ajax_serialize
			// http://www.the-art-of-web.com/javascript/escape/

		var serializedStrArr = [];
		for (var cSerializeKey in aSerializeObject) {
			serializedStrArr.push(encodeURIComponent(cSerializeKey) + '=' + encodeURIComponent(aSerializeObject[cSerializeKey]));
		}
		return serializedStrArr.join('&');
	}
};

// rev1 - _ff-addon-snippet-safedForPlatFS.js - https://gist.github.com/Noitidart/e6dbbe47fbacc06eb4ca
var _safedForPlatFS_pattWIN = /([\\*:?<>|\/\"])/g;
var _safedForPlatFS_pattNIXMAC = /\//g;
function safedForPlatFS(aStr, aOptions={}) {
	// short for getSafedForPlatformFilesystem - meaning after running this on it, you can safely use the return in a filename on this current platform
	// aOptions
	//	repStr - use this string, in place of the default repCharForSafePath in place of non-platform safe characters
	//	allPlatSafe - by default it will return a path safed for the current OS. Set this to true if you want to to get a string that can be used on ALL platforms filesystems. A Windows path is safe on all other platforms
	
	// set defaults on aOptions
	if (!('allPlatSafe' in aOptions)) {
		aOptions.allPlatSafe = false;
	}
	if (!('repStr' in aOptions)) {
		aOptions.repStr = '-';
	}
	
	var usePlat = aOptions.allPlatSafe ? 'winnt' : core.os.name; // a windows path is safe in all platforms so force that. IF they dont want all platforms then use the current platform
	switch (usePlat) {
		case 'winnt':
		case 'winmo':
		case 'wince':
		
				return aStr.replace(_safedForPlatFS_pattWIN, aOptions.repStr);
				
			break;
		default:
		
				return aStr.replace(_safedForPlatFS_pattNIXMAC, aOptions.repStr);
	}
}
// end - common helper functions